---
layout: post
title:  "Mickey"
date:   2025-04-11 19:24:00 -0400
categories: programming-languages
---
In UML's Computer Architecture course, we learn about how CPUs work by examining the [MIC-1](https://en.wikipedia.org/wiki/MIC-1) architecture invented by Andrew Tanenbaum. From what I understand, the most popular educational architecture like this is [LC-3](https://en.wikipedia.org/wiki/Little_Computer_3), and MIC-1 seems very rarely used in comparison. In fact, the MIC-1 Wikipedia page mentions the [simulator and assembler](https://github.com/jeapostrophe/mic1) our professors developed.

When I took COMP3080 a year ago, I was forced to deal with the tedium of writing assembly and even microcode by hand. I began to wonder if it was possible to write a programming language for such an underpowered architecture, but I didn't really know enough about compilers at the time to make much progress on this idea.

Recently, I started work on Mickey, a language which compiles to MIC-1 assembly. It is meant to be similar to C, but with more modern syntax. Here is a code sample:
```
fun factorial(x: int): int
begin
	if x <= 0 then
		return 1
	else
		return x * factorial(x - 1)
	end
end

fun main(): int
begin
	return factorial(8)
end
```
Mickey features roughly what you'd expect from a compiled language like this. Functions, stack-allocated local variables, static typing, type casting, arithmetic operations (multiplication and division are in software), comparisons, logical operations, pointers, even a memory allocator. Strings are work in progress. Hopefully coming soon are structs, type definitions, maybe even floating point math. Once those are done, I'll consider this language complete. In the mean time, let's explore how exactly this language works.

# Lexing and parsing

The whole language is implemented in OCaml. We start with a lexer and parser, which are generated by ocamllex and Menhir respectively. I'm not a huge fan of Menhir: it has a crazy learning curve and might as well not have error messages. Seriously: when you have a syntax error it will always just give you `Fatal error: exception Mickey.Parser.MenhirBasics.Error`. No filenames, no line numbers, not even the grammar rule that was violated. "There was an error somewhere, you figure out the rest."

The parser takes in text from a file and then produces an AST. The AST is an algebraic data type, with each option representing 1 type of statement:
{% highlight ocaml %}
type t =
| SBlock of t list
| SImport of string
| SGlobals of (string * Type.t) list * t
| SFun of string * (string * Type.t) list * Type.t * (string * Type.t) list * t
| SAssign of string * Exp.t
| SPtrAssign of Exp.t * Exp.t
| SCall of string * Exp.t list
| SIf of Exp.t * t * t
| SWhile of Exp.t * t
| SReturn of Exp.t option
| SAsm of string
{% endhighlight %}
Expressions and statements are segregated from each other into 2 separate types. I'm not sure if this is necessary or even a good idea, but that's how I set it up. My other programming language, Oops, has only 1 type for ASTs even though it also has a statement/expression distinction (but the only statements are assignments and definitions of things like functions, structs, modules, etc.).

# Type checking

The next step is for the AST to get type checked. First, in the `Type_check.process_defs` function, the definitions present in the tree get processed to create a type environment, which maps from global variable/function names to their types. After that is when the actual type checking happens, in `Type_check.type_check`. `type_check` type checks statements while `type_of` type checks expressions. These functions take an AST and a type environment, and do pattern matching on the AST to figure out what its type is supposed to be. For most statements, this type is `TNoReturn`, which is the type of a function body that hasn't returned anything yet. We don't want this. Functions that return `void` should explicitly return. We also do checks here to make sure values being assigned to variables are the types that they're expected to be, and that if and while conditions are booleans.

For expressions, if they're literal booleans, integers, or strings, their type is obvious. Variables are whatever type they're defined to be. Type casts allow you to say that any value is of any type, which probably isn't good, but I need it for the memory allocator. `type_of_call` determines the type of a function call, and it's needed to reduce code reuse because function calls are both statements and expressions. See why separating them might not have been a good idea? Most of the time, determining a function call's type is trivial: it's whatever the return type is. But we need to make sure that whatever is returned actually lines up with what the programmer says it is. We also need to make sure that the arguments are of the correct type, and that the thing being called is a function in the first place. Like in C, functions can only be referred to by name in Mickey, there's no lambdas or closures. However, I store functions and normal variables in the same type environment, which means that you could theoretically call anything if you cast it to a function type (but that's syntactically impossible).

# Compilation

After everything has been type checked and verified to be okay, compilation happens. Compilation happens in 4 separate functions though: `Compile.compile_global_init`, `Compile.compile_globals`, `Compile.comple_stmt`, and `Compile.compile_exp`. In the final .asm file produced by compilation, we want things to be laid out in a very certain order: first, the global variables are initialized; then a call to the main function; then the prelude, which includes definitions for operators, the memory allocation functions alloc and free, and functions to get and set local variables and function arguments (why these are needed will be discussed shortly); space for the global variables; the user's code; then finally space for the heap.

`compile_global_init` compiles only the code which is responsible for initializing global variables. If such code is present, it must be inside a `globals` block at the beginning of a file:
```
globals
	x: int # all variable declarations and definitions are separate, and new variables can only be declared in a globals block or in the locals block of a function definition
begin
	x = 5
end
```
If a file imports another file, these global init blocks will all be placed one after the other.

`compile_globals` just emits assembler directives to allocate space for global variables.

`compile_stmt` and `compile_exp` are where most stuff happens. These functions take an AST and a context, which stores the stack offsets of local variables and function arguments.